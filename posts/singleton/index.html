<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=content-language content="zh-cn"><meta name=author content="李伟成"><meta name=description content="通常创建单件的代码都是长这样的：
class USingleton { public: static USingleton* Instance() { if (Instance == null) { Instance = new USingleton(); } return Instance; } private: USingleton() {} USingleton* Instance; } 最近看了《游戏编程模式》中对于单件的描述发现了个更安全的写法：
class USingleton { public: static USingleton& Instance() { if (Instance == null) { Instance = new USingleton(); } return *Instance; } private: USingleton() {} USingleton* Instance; } 这样返回的是单件类实例的引用而不是指针。 以下是个更现代的版本：
class USingleton { public: static USingleton& Instance() { static USingleton Instance; return Instance; } private: USingleton() {} }  C++11保证一个局部静态变量的初始化只进行一次，哪怕是在多线程的情况下也是如此。所以，如果你有一个现代C++编译器的话，这份代码是线程安全的。"><meta name=keywords content="博客,游戏开发,个人"><meta name=twitter:card content="summary"><meta name=twitter:title content="创建单件的方法"><meta name=twitter:description content="通常创建单件的代码都是长这样的：
class USingleton { public: static USingleton* Instance() { if (Instance == null) { Instance = new USingleton(); } return Instance; } private: USingleton() {} USingleton* Instance; } 最近看了《游戏编程模式》中对于单件的描述发现了个更安全的写法：
class USingleton { public: static USingleton& Instance() { if (Instance == null) { Instance = new USingleton(); } return *Instance; } private: USingleton() {} USingleton* Instance; } 这样返回的是单件类实例的引用而不是指针。 以下是个更现代的版本：
class USingleton { public: static USingleton& Instance() { static USingleton Instance; return Instance; } private: USingleton() {} }  C++11保证一个局部静态变量的初始化只进行一次，哪怕是在多线程的情况下也是如此。所以，如果你有一个现代C++编译器的话，这份代码是线程安全的。"><meta property="og:title" content="创建单件的方法"><meta property="og:description" content="通常创建单件的代码都是长这样的：
class USingleton { public: static USingleton* Instance() { if (Instance == null) { Instance = new USingleton(); } return Instance; } private: USingleton() {} USingleton* Instance; } 最近看了《游戏编程模式》中对于单件的描述发现了个更安全的写法：
class USingleton { public: static USingleton& Instance() { if (Instance == null) { Instance = new USingleton(); } return *Instance; } private: USingleton() {} USingleton* Instance; } 这样返回的是单件类实例的引用而不是指针。 以下是个更现代的版本：
class USingleton { public: static USingleton& Instance() { static USingleton Instance; return Instance; } private: USingleton() {} }  C++11保证一个局部静态变量的初始化只进行一次，哪怕是在多线程的情况下也是如此。所以，如果你有一个现代C++编译器的话，这份代码是线程安全的。"><meta property="og:type" content="article"><meta property="og:url" content="https://calvincwl.github.io/posts/singleton/"><meta property="article:published_time" content="2017-06-07T00:00:00+00:00"><meta property="article:modified_time" content="2017-06-12T00:00:00+00:00"><title>创建单件的方法 · 神の記述</title><link rel=canonical href=https://calvincwl.github.io/posts/singleton/><script src=https://kit.fontawesome.com/d443c6acc0.js crossorigin=anonymous></script><link rel=stylesheet href=/css/coder.min.4e15cc690401543c744f350c15d4095d0a0e3988eaed0571c42f72199379c73f.css integrity="sha256-ThXMaQQBVDx0TzUMFdQJXQoOOYjq7QVxxC9yGZN5xz8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.89c82b6022b96f77aeb521b240daec4f87ea029d84d1c78b8acd0735b91b3c92.css integrity="sha256-icgrYCK5b3eutSGyQNrsT4fqAp2E0ceLis0HNbkbPJI=" crossorigin=anonymous media=screen><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><script defer src=https://twemoji.maxcdn.com/v/13.0.1/twemoji.min.js integrity=sha384-5f4X0lBluNY/Ib4VhGx0Pf6iDCF99VGXJIyYy7dDLY5QlEd7Ap0hICSSZA1XYbc4 crossorigin=anonymous></script><meta name=generator content="Hugo 0.80.0"></head><body class=colorscheme-auto onload=twemoji.parse(document.body);><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=/>神の記述</a>
<input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/about/>关于</a></li><li class=navigation-item><a class=navigation-link href=/posts/>博客</a></li><li class=navigation-item><a class=navigation-link href=/contact/>联系我</a></li><li class="navigation-item menu-separator"><span>|</span></li><li class=navigation-item><a href=https://calvincwl.github.io/en/>English</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://calvincwl.github.io/posts/singleton/>创建单件的方法</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa fa-calendar" aria-hidden=true></i><time datetime=2017-06-07T00:00:00Z>2017-06-07</time></span>
<span class=reading-time><i class="fa fa-clock-o" aria-hidden=true></i>阅读时间：1 分钟</span></div><div class=categories><i class="fa fa-folder" aria-hidden=true></i><a href=/categories/c++/>C++</a></div><div class=tags><i class="fa fa-tag" aria-hidden=true></i><a href=/tags/singleton/>singleton</a></div></div></header><div><p>通常创建单件的代码都是长这样的：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=font-weight:700>class</span> <span style=font-weight:700>USingleton</span>
{
<span style=font-weight:700>public</span>:
	<span style=font-weight:700>static</span> USingleton* Instance()
	{
		<span style=font-weight:700>if</span> (Instance == null)
		{
			Instance = <span style=font-weight:700>new</span> USingleton();
		}
		<span style=font-weight:700>return</span> Instance;
	}

<span style=font-weight:700>private</span>:
	USingleton() {}

	USingleton* Instance;
}
</code></pre></div><p>最近看了《游戏编程模式》中对于单件的描述发现了个更安全的写法：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=font-weight:700>class</span> <span style=font-weight:700>USingleton</span>
{
<span style=font-weight:700>public</span>:
	<span style=font-weight:700>static</span> USingleton&amp; Instance()
	{
		<span style=font-weight:700>if</span> (Instance == null)
		{
			Instance = <span style=font-weight:700>new</span> USingleton();
		}
		<span style=font-weight:700>return</span> *Instance;
	}

<span style=font-weight:700>private</span>:
	USingleton() {}

	USingleton* Instance;
}
</code></pre></div><p>这样返回的是单件类实例的引用而不是指针。
以下是个更现代的版本：</p><div class=highlight><pre style=background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=font-weight:700>class</span> <span style=font-weight:700>USingleton</span>
{
<span style=font-weight:700>public</span>:
	<span style=font-weight:700>static</span> USingleton&amp; Instance()
	{
		<span style=font-weight:700>static</span> USingleton Instance;
		<span style=font-weight:700>return</span> Instance;
	}

<span style=font-weight:700>private</span>:
	USingleton() {}
}
</code></pre></div><blockquote><p>C++11保证一个局部静态变量的初始化只进行一次，哪怕是在多线程的情况下也是如此。所以，如果你有一个现代C++编译器的话，这份代码是线程安全的。</p></blockquote></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2017 -
2021
李伟成
·
技术支持 <a href=https://gohugo.io/>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/>Coder</a>.</section></footer></main><script src=/js/dark-mode.min.0213e1773e6d1c5a644f847c67a6f8abac49a3776e2976f6008038af8c5b76a1.js></script></body></html>