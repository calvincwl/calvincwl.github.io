<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>singleton on 神の記述</title><link>https://calvincwl.github.io/tags/singleton/</link><description>Recent content in singleton on 神の記述</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 07 Jun 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://calvincwl.github.io/tags/singleton/index.xml" rel="self" type="application/rss+xml"/><item><title>创建单件的方法</title><link>https://calvincwl.github.io/posts/singleton/</link><pubDate>Wed, 07 Jun 2017 00:00:00 +0000</pubDate><guid>https://calvincwl.github.io/posts/singleton/</guid><description>通常创建单件的代码都是长这样的：
class USingleton { public: static USingleton* Instance() { if (Instance == null) { Instance = new USingleton(); } return Instance; } private: USingleton() {} USingleton* Instance; } 最近看了《游戏编程模式》中对于单件的描述发现了个更安全的写法：
class USingleton { public: static USingleton&amp;amp; Instance() { if (Instance == null) { Instance = new USingleton(); } return *Instance; } private: USingleton() {} USingleton* Instance; } 这样返回的是单件类实例的引用而不是指针。 以下是个更现代的版本：
class USingleton { public: static USingleton&amp;amp; Instance() { static USingleton Instance; return Instance; } private: USingleton() {} } C++11保证一个局部静态变量的初始化只进行一次，哪怕是在多线程的情况下也是如此。所以，如果你有一个现代C++编译器的话，这份代码是线程安全的。</description></item></channel></rss>